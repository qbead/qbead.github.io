<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="apple-touch-icon-precomposed" href="/colorwheel180.png">
  <link rel="icon" href="/colorwheel196.png">
  <meta property="og:title" content="The SpinWheel" />
  <meta property="og:type" content="website" />
  <meta property="og:description" content="Children have the natural curiosity and capacity to engineer a better world. Our kits just remind them." />
  <meta property="og:image" content="https://spinwearables.com/hanging.jpg" />
  <link rel="image_src" href="https://spinwearables.com/hanging.jpg" />
  <meta name="keywords" content="stroboscope, photography, fast motion" />
  <title>Stroboscopes and stroboscopic photography</title>
  <style>
  </style>
  <style>
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/custom.css" />
  <link rel="stylesheet" href="/custom_book.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<!-- Matomo -->
<script type="text/javascript">
  var _paq = window._paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//matomo.spinwearables.com/";
    _paq.push(['setTrackerUrl', u+'matomo.php']);
    _paq.push(['setSiteId', '1']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<!-- End Matomo Code -->
</head>
<body>
<!-- Matomo Image Tracker-->
<noscript><img src="https://matomo.spinwearables.com/matomo.php?idsite=1&amp;rec=1" style="border:0" alt="" /></noscript>
<!-- End Matomo -->
<header>
<div class="nav">
<a href="/">The SpinWheel</a>
 | 
<a href="/book">The Field Guide</a>
</div>
<h1 class="title">Stroboscopes and stroboscopic photography</h1>
</header>
<main>
<div class="further-reading">
<p>When trying to take a photo of a fast moving object (or even when we simply try to observe that object with our eyes), all we usually see is a blur. However, if the object performs a repetitive motion (e.g. the blades of a fan or a helicopter), and we use a fast-flashing light source, we might be able to synchronise the illumination with the motion, such that the object appears immobile to the camera. The camera will only be able to see an illuminated object when the object is in one particular location. This method is known as “stroboscopic photography” and we will explore it here.</p>
</div>
<div class="warning">
<p>This adventure will involve bright flashing lights. Do not attempt the activities here if you have light sensitivity or are alone.</p>
</div>
<p>Consider this stick figure drawn on one of the blades of a fan:</p>
<style>
.strobanim {
  justify-content: center;
  display: flex;
  flex-direction: row;
  position: relative;
}
.strobanim > canvas {
  border: solid 1px black;
  margin: 2px;
}
</style>
<div id="stationary_stick_figure" class="strobanim">
<canvas width="200" height="200">
</canvas>
</div>
<script>
var rotstep = 3.1415 / 25.324;

function draw_stick_figure(ctx) {
  ctx.lineWidth = 10;
  ctx.beginPath();
  ctx.arc(100, 55, 50, 0, Math.PI * 2, true); // Outer circle
  ctx.moveTo(135, 55);
  ctx.arc(100, 55, 35, 0, Math.PI, false); // Mouth (clockwise)
  ctx.moveTo(90, 45);
  ctx.arc(85, 45, 5, 0, Math.PI * 2, true); // Left eye
  ctx.moveTo(120, 45);
  ctx.arc(115, 45, 5, 0, Math.PI * 2, true); // Right eye
  ctx.stroke();
}

const stationary_stick_figure = document.getElementById('stationary_stick_figure');
const ssf_ctx = stationary_stick_figure.getElementsByTagName('canvas')[0].getContext('2d');

draw_stick_figure(ssf_ctx);
</script>
<p>If the blades are rotating at even moderate speed, all we will be able to see is a blur:</p>
<div id="rotating_stick_figure" class="strobanim">
<canvas width="200" height="200">
</canvas>
</div>
<script>
const rotating_stick_figure = document.getElementById('rotating_stick_figure');
const rsf_ctx = rotating_stick_figure.getElementsByTagName('canvas')[0].getContext('2d');
var rsf_canvas_buffer = document.createElement('canvas');
var rsf_ctx_buffer = rsf_canvas_buffer.getContext('2d');
rsf_ctx_buffer.fillStyle = "rgba(255,255,255,0.15)";
draw_stick_figure(rsf_ctx_buffer);
for (var i=0; i<=2; i++) {
  rsf_ctx_buffer.fillRect(0,0,200,200);
  rsf_ctx_buffer.translate(100,100);
  rsf_ctx_buffer.rotate(rotstep/4);
  rsf_ctx_buffer.translate(-100,-100);
  draw_stick_figure(rsf_ctx_buffer);
}
function rsf_draw() {
  rsf_ctx.translate(100,100);
  rsf_ctx.rotate(rotstep);
  rsf_ctx.translate(-100,-100);
  rsf_ctx.drawImage(rsf_canvas_buffer, 0, 0);
  window.requestAnimationFrame(rsf_draw);
}
rsf_draw();
</script>
<p>However, imagine that the light source illuminating this fan blade was synchronized such that it briefly flashes only when the blade is in the upright position. At any other time, there is no light and the camera does not see anything. To the camera (or our eyes) it would look like the blade is not moving, simply because the blade is in darkness most of the time and it is illuminated in only one particular position. Certainly, the flashing would have to be very rapid, but it is not difficult to make a rapidly flashing light. We will do it shortly with the SpinWheel.</p>
<p>Below is a visualization that attempts to showcase this phenomenon. On the left is the rotating image as seen if it is illuminated by a normal flashlight. On the right is the same image as it would be seen if the light source was intermittently flashing. The sliders let you change the frequency of the flashes and the relative duration of illumination and consecutive darkness. Can you adjust the sliders such that the right image appears always in the same location.</p>
<div style="text-align:center">
<strong>Relative duration:</strong><br>briefly on<input type="range" min="10" max="100" value="50" id="strobduty">always on
</div>
<div style="text-align:center">
<strong>Frequency (or period):</strong><br>flash often<input type="range" min="10" max="100" value="100" id="strobperiod">flash rarely
</div>
<div style="text-align:center">
Light turns on every <strong id=visperiod></strong> seconds for a duration of <strong id=visduty></strong> seconds.
</div>
<div id="strob_stick_figure" class="strobanim">
<canvas id="strob_all" width="200" height="200">
</canvas>
<canvas id="strob_sync" width="200" height="200">
</canvas>
</div>
<script>
const visduty = document.getElementById('visduty');
const visperiod = document.getElementById('visperiod');
const strobduty = document.getElementById('strobduty');
const strobperiod = document.getElementById('strobperiod');
const strob_stick_figure = document.getElementById('strob_stick_figure');
const strobsf_canvas = strob_stick_figure.getElementsByTagName('canvas')[0];
const strobsf_ctx = strobsf_canvas.getContext('2d');
const syncsf_ctx = strob_stick_figure.getElementsByTagName('canvas')[1].getContext('2d');
var strobsf_canvas_buffer = document.createElement('canvas');
var strobsf_ctx_buffer = strobsf_canvas_buffer.getContext('2d');
var strobison = false;
var firstframe = false;
strobsf_ctx.fillStyle = "rgba(200,40,40,0.55)";
strobsf_ctx_buffer.fillStyle = "rgba(255,255,255,0.15)";
syncsf_ctx.fillStyle = "rgba(255,255,255,0.15)";
draw_stick_figure(strobsf_ctx_buffer);
for (var i=0; i<=2; i++) {
  strobsf_ctx_buffer.fillRect(0,0,200,200);
  strobsf_ctx_buffer.translate(100,100);
  strobsf_ctx_buffer.rotate(rotstep/4);
  strobsf_ctx_buffer.translate(-100,-100);
  draw_stick_figure(strobsf_ctx_buffer);
}
function strobsf_draw() {
  strobsf_ctx.translate(100,100);
  strobsf_ctx.rotate(rotstep);
  strobsf_ctx.translate(-100,-100);
  strobsf_ctx.drawImage(strobsf_canvas_buffer, 0, 0);
  if (strobison) {
    syncsf_ctx.drawImage(strobsf_canvas, 0, 0);
    if (firstframe) {
      //strobsf_ctx.fillRect(0,0,200,200);
      firstframe = false;
    }
  } else {
    syncsf_ctx.fillRect(0,0,200,200);
  }
  window.requestAnimationFrame(strobsf_draw);
}
function turn_strob_on() {
  strobison = true;
  firstframe = true;
  setTimeout(turn_strob_off, strobduty.value*strobperiod.value/10);
}
function turn_strob_off() {
  strobison = false;
  setTimeout(turn_strob_on, (100-strobduty.value)*strobperiod.value/10);
}
strobperiod.oninput = function(){visperiod.innerHTML=`${strobperiod.value/100}`;visduty.innerHTML=`${strobduty.value*strobperiod.value/10000}`;}
strobduty.oninput = function(){visduty.innerHTML=`${strobduty.value*strobperiod.value/10000}`;}
strobperiod.oninput();
strobsf_draw();
turn_strob_on();
</script>
<p>It was not that easy, was it? There are a couple of features you might have noticed:</p>
<ul>
<li>It is important to distinguish the “period” of the flashes (i.e., the time between the onsets of two consecutive flashes) from the duration of each flash (i.e., the time over which a flash is on). The duration is always less than a period. The duration of the flash plus the duration of the darkness is equal to the period.</li>
<li>It is easier to calibrate the period of the flashes if the duration of each flash is short. If the illumination is on for too long, it does not matter whether the flashing frequency is synchronized to the motion of the stick figure: the stick figure will still move too much during that duration and will look like a blur. Set the duration of the flash to a very low value by using the top slider.</li>
<li>Now that the duration is low and the image is as sharp as it will get, try to change the periods of the flashes so that the image on the right appears always in the same location. After performing this procedure, could you determine how many seconds does it take for the stick figure to make one full rotation?</li>
</ul>
<h2 id="real-world-example">Real world example</h2>
<p>We can do this with a real stick figure attached to a real fan or toy motor:</p>
<figure>
<video src="/images/strob_blur.mp4" controls>
</video>
<figcaption>
Illuminating a stick figure attached to a toy motor. The illumination is even and constant, leading to the fast-moving stick figure looking like a blur.
</figcaption>
</figure>
<figure>
<video src="/images/strob_good.mp4" controls>
</video>
<figcaption>
Same stick figure illuminated by a light source flashing roughly a hundred times each second. Notice two things: it took us a while to precisely calibrate the flashing period and until we did that the stick figure still looked like a blur moving all over the place; while at the end we do have the stick figure mostly in the same location, it still looks a bit blurry – this is because even during the short time the light is on (three ten-thousands of a second) the stick moves a couple of millimeters.
</figcaption>
</figure>
<h2 id="creating-your-own-stroboscope">Creating your own Stroboscope</h2>
<p>This was achieved by using the SpinWheel’s LEDs (yes, they are capable of such high speeds). We will now see how this was done so you can try at home. A good target for the device we will create (called a stroboscope) would be any random fan you have at home (which usually perform anything between 50 and 200 rotations per second). Another interesting target would be rapid consecutive droplets of water coming from a leaky faucet (if you time the flashes to be just a bit shorter than the period between droplets, it would look like the droplets are slowly moving upwards).</p>
<p>But first, let us overwrite the default settings of the SpinWheel and set the large LEDs to maximum (blinding) brightness:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dt">void</span> setup() {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  SpinWheel.begin();</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  SpinWheel.setBrightness(<span class="dv">255</span>);</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>We also would like to define a constant that tells us how long we need to wait between flashes (it will be measured in microseconds, i.e., a millionth of a second):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dt">long</span> default_delay_time = <span class="dv">10000</span>;</span></code></pre></div>
<p>Notice that this time we are declaring this variable as <code>long</code> not as <code>int</code>. <code>long</code> variables are a particular type of integers that can store large values (much larger than the usual limit of around 30 000 that can be stored in an <code>int</code>).</p>
<p>Now comes the main part of the code, the one that forces all the large LEDs to flash rapidly:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">void</span> loop() {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="co">// Turn the LEDs on.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  SpinWheel.setLargeLEDsUniform(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>);</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  SpinWheel.drawLargeLEDFrame();</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  <span class="co">// Wait for a very brief moment of time,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  <span class="co">// just 3% of the total period.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>  delayMicroseconds(<span class="fl">0.03</span>*default_delay_time);</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  <span class="co">// Turn the LEDs off.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>  SpinWheel.setLargeLEDsUniform(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>  SpinWheel.drawLargeLEDFrame();</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>  <span class="co">// Wait the other 97% of the period in darkness.</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>  delayMicroseconds(<span class="fl">0.97</span>*default_delay_time);</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>}</span></code></pre></div>
<p>Your eye probably will not be able to notice the rapid flashes and the illumination would look smooth, but if you shine it on a rapidly moving object you will be able to see the stroboscopic effect. Notice that we used the <code>drawLargeLEDFrame</code> function instead of the <code>drawFrame</code> function – we did this because the small LEDs are drastically slower and do not work well when the <code>delay</code> functions are in use. By sticking to only the large LEDs this was not a problem.</p>
<p>We have one last issue to address, namely, the fact that this code works only for objects that repeat their motion exactly 100 times a second (every 10 000 microseconds, i.e., every 10 milliseconds). We need a way to “calibrate” the period of the stroboscopic light. We can use the <a href="/tilt">tilt sensor</a> of the SpinWheel as a “turning knob” that changes the total period. The x-axis acceleration measurement will vary from -1 to +1 depending on the tilt of the device. We can introduce a <code>correction</code> variable:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">long</span> default_delay_time = <span class="dv">10000</span>;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="dt">long</span> max_correction = <span class="dv">800</span>;</span></code></pre></div>
<p>If we define the period as <code>default_delay_time + SpinWheel.ax * max_correction</code> we can use the tilt to vary its value from <code>9200 = 10000-800</code> to <code>10800 = 10000+800</code>. The entirety of the code would look like:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">void</span> loop() {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="co">// Measure the tilt and use it to modify the period.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  SpinWheel.readIMU();</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span class="dt">long</span> delaytime = default_delay_time + SpinWheel.ax * max_correction;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>  </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  <span class="co">// Turn the LEDs on and wait a short fraction of the total period.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>  SpinWheel.setLargeLEDsUniform(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>);</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>  SpinWheel.drawLargeLEDFrame();</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>  delayMicroseconds(<span class="fl">0.03</span>*delaytime);</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>  <span class="co">// Turn the LEDs off and wait for the rest of the period.</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>  SpinWheel.setLargeLEDsUniform(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>  SpinWheel.drawLargeLEDFrame();</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>  delayMicroseconds(<span class="fl">0.97</span>*delaytime);</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>}</span></code></pre></div>
<p>This code can be found in <a href="/codedoc/examples/Stroboscope/Stroboscope.ino.html"><code>Examples → SpinWearables → Stroboscope</code></a>. Before using it for the first time it could help making the periods much larger, on a scale that a human can perceive, in order to observe the flashing behavior for yourself. Try setting the default period to 100 000 microseconds (one-tenth of a second) and the correction to 50 000 microseconds (one-twentieth of a second) and tilt the device to see how the period changes.</p>
<p>Whenever you target a new repetitive motion for a stroboscopic study, you probably will need to reupload the code multiple times as you pinpoint the correct value for the period. At first it might help having a <code>max_correction</code> which is large, almost as large as <code>default_delay_time</code>. That would make it easier for you to span a large interval of possible periods. As you pinpoint the correct value, you can make <code>max_correction</code> smaller and smaller, which makes the stroboscope much easier to calibrate to a precise value (as it becomes less sensitive to unintentional changes in the tilt due to trembles in your hand).</p>
<p>Lastly, could you guess what happens if you use a period that is half (or one-third or another simple fraction) of the correct period?</p>
<figure>
<video src="/images/strob_half.mp4" controls>
</video>
<figcaption>
The stick figure illuminated with continuous light and with rapidly flashing light at a period equal to one-half of the period of the rotating stick. Why does the image double up?
</figcaption>
</figure>
<h2 id="stroboscopic-illusions-on-camera">Stroboscopic illusions on camera</h2>
<p>This effect can also be observed when the frame rate of a camera syncs up with a repetitive motion being recorded. You can see in the video below, that the blades of a flying helicopter can look motionless even though they are actually rapidly spinning. The educational channel of Captain Disillusion goes into further detail, <a href="https://www.youtube.com/watch?v=mPHsRcI5LLQ">explaining the phenomenon</a>.</p>
<figure>
<video src="/images/strob_heli.mp4" controls>
</video>
<figcaption>
The shutter of the camera syncs up with the motion of the blades, creating an illusion of motionless blades. This particular occurrence happened at a soccer stadium in Esbjerg, but you can find many more examples online.
</figcaption>
</figure>
<script data-isso="//comments.spinwearables.com/"
data-isso-reply-to-self="false"
data-isso-require-author="true"
data-isso-require-email="true"
data-isso-avatar="false"
data-isso-vote="false"
src="//comments.spinwearables.com/js/embed.min.js"></script>
<section id="isso-thread"></section>
<script>
document.querySelector("#isso-thread").addEventListener(
  "click",
  function () {
    document.querySelectorAll("#isso-thread > div").forEach(function (x) {x.style.display = "block";});
  });
</script>
</main>
<div id="license">
<!--<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/cc-by-sa.png" /></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.-->
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/cc-by-sa.png" /></a></a> This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>. © SpinWearables LLC (<a href="/license">license and trademark details</a>)
</div>
</body>
</html>
